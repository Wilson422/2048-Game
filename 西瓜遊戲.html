<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>è¥¿ç“œéŠæˆ² - æ¥µè‡´å„ªåŒ–ç‰ˆ ğŸ‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

    body {
      margin: 0;
      background: #ffeaa7;
      font-family: 'Fredoka One', cursive, sans-serif;
      overflow: hidden; /* é˜²æ­¢æ²å‹• */
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      color: #5d4037;
    }

    #game-container {
      position: relative;
      width: 100%;
      max-width: 450px;
      height: 100vh;
      max-height: 800px;
      background: #fff8e1;
      box-shadow: 0 10px 30px rgba(0,0,0,0.15);
      border-radius: 12px;
      overflow: hidden;
    }

    /* UI Layer */
    .ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ° Canvas */
      z-index: 10;
    }

    .header {
      position: absolute;
      top: 15px;
      left: 20px;
    }

    .score-label {
      font-size: 16px;
      color: #fab1a0;
    }

    .score-number {
      font-size: 32px;
      color: #e17055;
    }

    .next-fruit-box {
      position: absolute;
      top: 15px;
      right: 20px;
      background: rgba(255, 255, 255, 0.8);
      border: 2px solid #fab1a0;
      border-radius: 10px;
      width: 70px;
      height: 70px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .next-label {
      font-size: 10px;
      color: #e17055;
      margin-bottom: 2px;
    }

    .next-icon {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }

    /* Canvas */
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    /* Game Over Screen */
    #game-over {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      z-index: 20;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      backdrop-filter: blur(4px);
    }

    #game-over h2 {
      color: #fff;
      font-size: 48px;
      margin: 0 0 20px 0;
      text-shadow: 2px 2px 0 #e17055;
    }

    button {
      background: #e17055;
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 24px;
      font-family: 'Fredoka One', cursive;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 4px 0 #c0392b;
      transition: transform 0.1s;
    }

    button:active {
      transform: translateY(4px);
      box-shadow: none;
    }
    
    /* Loading Guide Line */
    .guide-line {
      position: absolute;
      top: 100px;
      bottom: 0;
      width: 2px;
      border-left: 2px dashed rgba(0,0,0,0.2);
      transform: translateX(-50%);
      display: none; 
      z-index: 5;
    }

  </style>
</head>
<body>

  <div id="game-container">
    <!-- UI Layer -->
    <div class="ui-layer">
      <div class="header">
        <div class="score-label">SCORE</div>
        <div class="score-number" id="score">0</div>
      </div>
      <div class="next-fruit-box">
        <div class="next-label">NEXT</div>
        <div class="next-icon" id="next-fruit-icon">ğŸ’</div>
      </div>
      <div class="guide-line" id="guide-line"></div>
    </div>

    <!-- Game Over -->
    <div id="game-over">
      <h2>GAME OVER</h2>
      <button id="restart-btn">Try Again</button>
    </div>

    <canvas id="world"></canvas>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    // --- éŠæˆ²è¨­å®š ---
    const FRUITS = [
      { name: "æ«»æ¡ƒ", radius: 16, color: "#ff7675", score: 2,  emoji: "ğŸ’" },
      { name: "è‰è“", radius: 24, color: "#fd79a8", score: 4,  emoji: "ğŸ“" },
      { name: "è‘¡è„", radius: 32, color: "#a29bfe", score: 8,  emoji: "ğŸ‡" },
      { name: "æ©˜å­", radius: 38, color: "#ffeaa7", score: 16, emoji: "ğŸŠ" },
      { name: "æŸ¿å­", radius: 46, color: "#fab1a0", score: 32, emoji: "ğŸ¥­" },
      { name: "è˜‹æœ", radius: 56, color: "#d63031", score: 64, emoji: "ğŸ" },
      { name: "æ¢¨å­", radius: 66, color: "#55efc4", score: 128, emoji: "ğŸ" },
      { name: "æ¡ƒå­", radius: 78, color: "#fdcb6e", score: 256, emoji: "ğŸ‘" },
      { name: "é³³æ¢¨", radius: 92, color: "#ffeaa7", score: 512, emoji: "ğŸ" },
      { name: "å“ˆå¯†ç“œ", radius: 106, color: "#00b894", score: 1024, emoji: "ğŸˆ" },
      { name: "è¥¿ç“œ", radius: 120, color: "#00cec9", score: 2048, emoji: "ğŸ‰" },
    ];

    const GAME_WIDTH = 450; 
    const GAME_HEIGHT = 800;
    const WALL_THICKNESS = 100; // ç‰†å£åšåšä¸€é»é˜²æ­¢ç©¿é€

    // --- Matter.js æ¨¡çµ„ ---
    const { Engine, Render, Runner, World, Bodies, Body, Events, Composite, Composite: CompositeUtil } = Matter;

    // --- åˆå§‹åŒ–è®Šæ•¸ ---
    let engine, render, runner;
    let currentFruit = null;
    let nextFruitIndex = 0;
    let isClickable = true;
    let score = 0;
    let particles = [];
    let canvas, ctx;
    let guideLine;

    // --- DOM ---
    const scoreEl = document.getElementById('score');
    const nextFruitIcon = document.getElementById('next-fruit-icon');
    const gameOverScreen = document.getElementById('game-over');
    const restartBtn = document.getElementById('restart-btn');
    guideLine = document.getElementById('guide-line');

    function init() {
      // è¨­ç½® Canvas
      canvas = document.getElementById('world');
      canvas.width = GAME_WIDTH;
      canvas.height = GAME_HEIGHT;
      ctx = canvas.getContext('2d');

      // å‰µå»ºå¼•æ“
      engine = Engine.create();
      engine.world.gravity.y = 1.2; // ç¨å¾®é‡ä¸€é»ï¼Œæ‰‹æ„Ÿè¼ƒå¥½

      // å‰µå»ºæ¸²æŸ“å™¨ (æˆ‘å€‘ä¸»è¦ç”¨ Custom Renderï¼Œé€™è£¡åªç”¨ä¾†æ›è¼‰ï¼Œwireframes: false æ˜¯é—œéµ)
      // ä½†ç‚ºäº†æ›´è‡ªç”±çš„ç¹ªåœ–ï¼Œæˆ‘å€‘ä¸‹é¢æœƒè‡ªå·±å¯« render loopï¼Œé€™è£¡ä¸ä½¿ç”¨ Matter.Render çš„é è¨­ç¹ªåœ–
      
      // é‚Šç•Œ
      const ground = Bodies.rectangle(GAME_WIDTH/2, GAME_HEIGHT + WALL_THICKNESS/2 - 10, GAME_WIDTH, WALL_THICKNESS, { 
        isStatic: true, label: 'ground', render: { fillStyle: '#d63031' } 
      });
      const leftWall = Bodies.rectangle(0 - WALL_THICKNESS/2, GAME_HEIGHT/2, WALL_THICKNESS, GAME_HEIGHT * 2, { 
        isStatic: true, label: 'wall' 
      });
      const rightWall = Bodies.rectangle(GAME_WIDTH + WALL_THICKNESS/2, GAME_HEIGHT/2, WALL_THICKNESS, GAME_HEIGHT * 2, { 
        isStatic: true, label: 'wall' 
      });

      // æ­»ç·šå‚³æ„Ÿå™¨ (åœ¨é ‚éƒ¨é™„è¿‘)
      const topSensor = Bodies.rectangle(GAME_WIDTH/2, 120, GAME_WIDTH, 2, {
        isStatic: true,
        isSensor: true,
        label: 'topSensor',
        render: { visible: false } // çœ‹ä¸è¦‹
      });

      World.add(engine.world, [ground, leftWall, rightWall, topSensor]);

      // äº‹ä»¶ç›£è½
      Events.on(engine, 'collisionStart', handleCollisions);

      // è¼¸å…¥è™•ç†
      canvas.addEventListener('mousemove', updateInput);
      canvas.addEventListener('touchmove', (e) => { e.preventDefault(); updateInput(e.touches[0]); }, {passive: false});
      
      canvas.addEventListener('mouseup', handleInputRelease);
      canvas.addEventListener('touchend', handleInputRelease);

      restartBtn.addEventListener('click', resetGame);

      // é–‹å§‹å¾ªç’°
      runner = Runner.create();
      Runner.run(runner, engine);
      
      requestAnimationFrame(renderLoop);

      // æº–å‚™ç¬¬ä¸€é¡†
      score = 0;
      updateScore(0);
      setNextFruit();
      createNewCurrentFruit();
    }

    // --- éŠæˆ²é‚è¼¯ ---

    function getRandomIndex() {
      // åªç”¢ç”Ÿå‰ 5 ç¨®è¼ƒå°çš„æ°´æœ
      return Math.floor(Math.random() * 5); 
    }

    function setNextFruit() {
      nextFruitIndex = getRandomIndex();
      const f = FRUITS[nextFruitIndex];
      // é¡¯ç¤ºåœ¨ UI ä¸Š
      nextFruitIcon.innerText = f.emoji;
      nextFruitIcon.style.textShadow = `0 0 10px ${f.color}`;
    }

    function createNewCurrentFruit() {
      isClickable = true;
      // åœ¨é ‚éƒ¨ç”Ÿæˆä¸€å€‹ã€Œå‡ã€æ°´æœç”¨æ–¼ç„æº– (ä¸æ˜¯ç‰©ç†å¯¦é«”ï¼Œåªæ˜¯è®Šæ•¸è¨˜éŒ„)
      // æˆ‘å€‘æœƒåœ¨ render loop ç•«å‡ºå®ƒ
      currentFruit = {
        x: GAME_WIDTH / 2,
        y: 60,
        index: nextFruitIndex,
        isDropping: false
      };
      
      // æº–å‚™ä¸‹ä¸€å€‹
      setNextFruit();
      guideLine.style.display = 'block';
    }

    function updateInput(e) {
      if (!currentFruit || currentFruit.isDropping) return;
      
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      
      let x = (e.clientX - rect.left) * scaleX;
      
      // é™åˆ¶ç¯„åœ (ä¸è¦è®“æ°´æœè·‘å‡ºç‰†å£)
      const r = FRUITS[currentFruit.index].radius;
      if (x < r + 10) x = r + 10;
      if (x > GAME_WIDTH - r - 10) x = GAME_WIDTH - r - 10;

      currentFruit.x = x;
      
      // æ›´æ–°è¼”åŠ©ç·šä½ç½®
      guideLine.style.left = (currentFruit.x / GAME_WIDTH * 100) + '%';
    }

    function handleInputRelease(e) {
      if (!isClickable || !currentFruit || currentFruit.isDropping) return;
      isClickable = false;
      currentFruit.isDropping = true;
      guideLine.style.display = 'none';

      // çœŸæ­£å‰µå»ºç‰©ç†å¯¦é«”
      const idx = currentFruit.index;
      const r = FRUITS[idx].radius;
      
      const body = Bodies.circle(currentFruit.x, currentFruit.y, r, {
        restitution: 0.2, // å½ˆæ€§
        friction: 0.1,
        label: 'fruit',
        render: {
          fillStyle: FRUITS[idx].color
        }
      });
      
      // ç¶å®šè‡ªå®šç¾©å±¬æ€§
      body.fruitIndex = idx;
      body.fruitId = Date.now(); // å”¯ä¸€ID

      World.add(engine.world, body);

      // å»¶é²å¾Œç”Ÿæˆä¸‹ä¸€å€‹
      currentFruit = null;
      setTimeout(() => {
        createNewCurrentFruit();
      }, 800);
    }

    function handleCollisions(event) {
      const pairs = event.pairs;

      for (let i = 0; i < pairs.length; i++) {
        const bodyA = pairs[i].bodyA;
        const bodyB = pairs[i].bodyB;

        // æª¢æŸ¥æ˜¯å¦æ˜¯æ°´æœåˆæˆ
        if (bodyA.label === 'fruit' && bodyB.label === 'fruit') {
          if (bodyA.fruitIndex === bodyB.fruitIndex) {
            // é¿å…é‡è¤‡è™•ç† (Matter.js åŒä¸€å¹€å¯èƒ½è§¸ç™¼å¤šæ¬¡)
            if (bodyA.isResolving || bodyB.isResolving) continue;
            
            bodyA.isResolving = true;
            bodyB.isResolving = true;
            
            mergeFruits(bodyA, bodyB);
          }
        }
        
        // æª¢æŸ¥éŠæˆ²çµæŸ (ç¢°åˆ°é ‚éƒ¨æ­»ç·šä¸”é€Ÿåº¦æ¥µæ…¢)
        // ç°¡å–®é‚è¼¯ï¼šå¦‚æœæœ‰æ°´æœé•·æ™‚é–“åœç•™åœ¨æ­»ç·šä¸Šæ–¹ï¼Œå°±çµæŸ
        // é€™è£¡ç‚ºäº†ç°¡åŒ–ï¼Œæˆ‘å€‘åœ¨ render loop è£¡æª¢æŸ¥ Y è»¸æ›´ç›´è§€
      }
    }

    function mergeFruits(a, b) {
      const midX = (a.position.x + b.position.x) / 2;
      const midY = (a.position.y + b.position.y) / 2;
      const nextIdx = a.fruitIndex + 1;

      // ç§»é™¤èˆŠçš„
      World.remove(engine.world, [a, b]);
      
      // ç‰¹æ•ˆ
      createParticles(midX, midY, FRUITS[a.fruitIndex].color);

      // åŠ åˆ†
      const scoreAdd = FRUITS[a.fruitIndex].score; // ç”¨åˆæˆå‰çš„åˆ†æ•¸ç®—ï¼Œæˆ–åˆæˆå¾Œçš„éƒ½å¯ä»¥
      updateScore(score + scoreAdd);

      if (nextIdx < FRUITS.length) {
        const r = FRUITS[nextIdx].radius;
        const newBody = Bodies.circle(midX, midY, r, {
          restitution: 0.2,
          friction: 0.1,
          label: 'fruit',
          render: { fillStyle: FRUITS[nextIdx].color }
        });
        newBody.fruitIndex = nextIdx;
        World.add(engine.world, newBody);
        
        // çµ¦ä¸€é»æ¨åŠ›è®“å®ƒä¸æœƒé»åœ¨ä¸€èµ·
        // Body.setVelocity(newBody, { x: (Math.random()-0.5)*2, y: -2 });
      }
    }

    function updateScore(val) {
      score = val;
      scoreEl.innerText = score;
    }

    function createParticles(x, y, color) {
      for(let i=0; i<8; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 10,
          vy: (Math.random() - 0.5) * 10,
          life: 30,
          color: color,
          size: Math.random() * 6 + 4
        });
      }
    }

    function checkGameOver() {
      if (!isClickable) return; // åªæœ‰åœ¨å¯ä»¥ä¸‹è›‹çš„æ™‚å€™æ‰æª¢æŸ¥éœæ­¢çš„æ°´æœ
      const bodies = Composite.allBodies(engine.world);
      
      for (let body of bodies) {
        if (body.label === 'fruit') {
          // å¦‚æœæœ‰æ°´æœæº¢å‡ºè­¦æˆ’ç·š (y < 120) ä¸”é€Ÿåº¦å¾ˆæ…¢ (è¡¨ç¤ºå †ç–Šèµ·ä¾†äº†)
          if (body.position.y < 100 && body.speed < 0.2) {
             // Game Over
             gameOverScreen.style.display = 'flex';
             isClickable = false;
             currentFruit = null;
             guideLine.style.display = 'none';
             Runner.stop(runner);
             return;
          }
        }
      }
    }

    function resetGame() {
      World.clear(engine.world);
      Engine.clear(engine);
      
      // é‡æ–°åŠ ç‰†å£
      const ground = Bodies.rectangle(GAME_WIDTH/2, GAME_HEIGHT + WALL_THICKNESS/2 - 10, GAME_WIDTH, WALL_THICKNESS, { isStatic: true, label: 'ground' });
      const leftWall = Bodies.rectangle(0 - WALL_THICKNESS/2, GAME_HEIGHT/2, WALL_THICKNESS, GAME_HEIGHT * 2, { isStatic: true, label: 'wall' });
      const rightWall = Bodies.rectangle(GAME_WIDTH + WALL_THICKNESS/2, GAME_HEIGHT/2, WALL_THICKNESS, GAME_HEIGHT * 2, { isStatic: true, label: 'wall' });
      World.add(engine.world, [ground, leftWall, rightWall]);

      particles = [];
      score = 0;
      updateScore(0);
      gameOverScreen.style.display = 'none';
      
      runner = Runner.create();
      Runner.run(runner, engine);
      
      createNewCurrentFruit();
    }

    // --- æ¸²æŸ“å¾ªç’° (Custom Render) ---
    function renderLoop() {
      // æ¸…ç©ºç•«å¸ƒ
      ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

      // ç•«è¼”åŠ©ç·š (é›–ç„¶ CSS ç•«äº†ï¼Œä½†é€™è£¡å¯ä»¥ç•«ä¸€æ¢å¾ä¸Šåˆ°ä¸‹çš„é€æ˜ç·šå¢åŠ è³ªæ„Ÿ)
      // (çœç•¥ï¼Œç”¨ CSS çš„ guide-line å³å¯)

      // ç•«ç‰©ç†å¯¦é«”
      const bodies = Composite.allBodies(engine.world);
      ctx.lineWidth = 2;
      
      for (let body of bodies) {
        if (body.label === 'fruit') {
          drawFruit(body.position.x, body.position.y, body.angle, body.fruitIndex);
        }
      }

      // ç•«æ‰‹ä¸Šçš„æ°´æœ (Current Fruit)
      if (currentFruit && !currentFruit.isDropping) {
        drawFruit(currentFruit.x, currentFruit.y, 0, currentFruit.index, 1.0); // 1.0 opacity
      }

      // ç•«ç²’å­
      updateAndDrawParticles();

      // æª¢æŸ¥éŠæˆ²çµæŸ
      checkGameOver();

      requestAnimationFrame(renderLoop);
    }

    function drawFruit(x, y, angle, index, alpha = 1) {
      const f = FRUITS[index];
      const r = f.radius;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.globalAlpha = alpha;

      // 1. é™°å½±
      ctx.beginPath();
      ctx.arc(2, 4, r, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0,0,0,0.1)';
      ctx.fill();

      // 2. æœ¬é«”
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      ctx.fillStyle = f.color;
      ctx.fill();
      
      // 3. å…§ç™¼å…‰/é«˜å…‰ (è®“å®ƒçœ‹èµ·ä¾†åƒçƒé«”)
      const grad = ctx.createRadialGradient(-r*0.3, -r*0.3, r*0.2, 0, 0, r);
      grad.addColorStop(0, 'rgba(255,255,255,0.3)');
      grad.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = grad;
      ctx.fill();

      // 4. é‚Šæ¡† (å¡é€šæ„Ÿ)
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // 5. ç•«è‡‰ (ç°¡å–®çš„çœ¼ç›å˜´å·´)
      drawFace(ctx, r);

      // 6. Debug Emoji (å¦‚æœæƒ³çœ‹é€™æ˜¯ä»€éº¼æ°´æœ)
      // ctx.fillStyle = '#fff';
      // ctx.font = `${r}px Arial`;
      // ctx.fillText(f.emoji, -r/2, r/3);

      ctx.restore();
    }

    function drawFace(ctx, r) {
      ctx.fillStyle = '#5d4037';
      
      // çœ¼ç›
      const eyeX = r * 0.3;
      const eyeY = r * -0.1;
      const eyeSize = r * 0.15;
      
      // å·¦çœ¼
      ctx.beginPath();
      ctx.arc(-eyeX, eyeY, eyeSize, 0, Math.PI*2);
      ctx.fill();
      // å³çœ¼
      ctx.beginPath();
      ctx.arc(eyeX, eyeY, eyeSize, 0, Math.PI*2);
      ctx.fill();

      // å˜´å·´ (å¾®ç¬‘)
      ctx.beginPath();
      ctx.arc(0, 0, r * 0.25, 0.2 * Math.PI, 0.8 * Math.PI);
      ctx.stroke();
    }

    function updateAndDrawParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.5; // gravity
        p.life--;

        if (p.life <= 0) {
          particles.splice(i, 1);
          continue;
        }

        ctx.globalAlpha = p.life / 30;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    // å•Ÿå‹•
    init();

  </script>
</body>
</html>
